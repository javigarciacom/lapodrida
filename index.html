<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>La Podrida – Juego de Cartas</title>
  <style>
    /* RESET BÁSICO */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    /* Fondo: color #0b2a0f y la imagen en su tamaño original, centrada */
    body {
      background: #0b2a0f url('img/fondoiPocha-hd.png') no-repeat center center;
      font-family: sans-serif;
      color: #fff;
    }
    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    /* Botones principales modernizados */
    /* Todos los botones (Nuevo Juego, Puntuación, Siguiente Ronda) y los botones circulares para la apuesta tendrán: 
       Estado normal: #218f3e 
       Hover: #1e8138 */
    #new-game, #scoreboard-button, #restart {
      position: absolute;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      z-index: 10;
      background-color: #218f3e;
      color: #fff;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
    #new-game {
      top: 10px;
      left: 10px;
    }
    /* El botón de puntuación se coloca 10px más abajo */
    #scoreboard-button {
      top: 60px;
      left: 10px;
    }
    #restart {
      bottom: 10px;
      right: 10px;
      display: none;
    }
    #new-game:hover, #scoreboard-button:hover, #restart:hover {
      background-color: #1e8138;
    }
    #new-game:active, #scoreboard-button:active, #restart:active {
      transform: scale(0.98);
    }
    /* Tapete de 350×350px sin color de fondo ni borde */
    #trick-area {
      position: absolute;
      width: 350px;
      height: 350px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: transparent;
      border: none;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1;
    }
    /* Caja de ayuda: se posiciona por encima del tapete */
    #message {
      position: absolute;
      top: calc(50% - 250px);
      left: 50%;
      transform: translateX(-50%);
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 5px;
      z-index: 10;
      text-align: center;
      max-height: 100px;
      overflow-y: auto;
    }
    /* Marcador de ronda: etiqueta sin dos puntos */
    #round-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.8);
      color: black;
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      text-align: center;
    }
    /* Áreas de los jugadores */
    .player-area {
      position: absolute;
      text-align: center;
    }
    #north {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
    }
    #east {
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
    }
    #south {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }
    #west {
      top: 50%;
      left: 20px;
      transform: translateY(-50%);
    }
    /* Contenedor de apuestas para el jugador humano */
    #bid-area {
      margin-bottom: 10px;
    }
    /* Botones para elegir apuesta (bid) modernizados y circulares */
    .bid-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #218f3e;
      color: #fff;
      font-size: 20px;
      border: none;
      margin: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .bid-button:hover {
      background-color: #1e8138;
    }
    .bid-button:active {
      transform: scale(0.95);
    }
    /* Transición para las cartas para suavizar los cambios en la mano */
    .card {
      width: 94px;
      height: 140px;
      margin: 3px 5px;
      transition: all 0.3s ease;
    }
    /* Las cartas jugadas tienen transición para moverse suavemente */
    .played-card {
      position: absolute;
      width: 94px;
      height: 140px;
      z-index: 5;
      transition: all 0.5s ease-out;
    }
    /* Resalta carta válida en la mano */
    .card.valid {
      filter: drop-shadow(0 0 15px yellow);
    }
    /* Resalta la carta ganadora en la baza */
    .winning-card {
      filter: drop-shadow(0 0 15px gold);
    }
    /* Caja de estado para cada jugador */
    .status-box {
      background: rgba(255,255,255,0.8);
      color: black;
      border: 1px solid #000;
      border-radius: 5px;
      padding: 5px;
      margin-top: 5px;
      font-size: 14px;
    }
    /* ------------------ SCOREBOARD OVERLAY ------------------ */
    #scoreboard-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      color: black;
      font-family: "Courier New", monospace;
      padding: 20px;
      border: 2px solid #000;
      z-index: 1000;
      max-height: 90vh;
      overflow: auto;
    }
    #scoreboard-table {
      border-collapse: collapse;
      width: 100%;
    }
    #scoreboard-table th, #scoreboard-table td {
      border: 1px solid black;
      padding: 5px;
      text-align: center;
    }
    .main-column {
      border-right: 2px solid black;
    }
    .separator {
      border-bottom: 2px solid black;
    }
    #scoreboard-close {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="game">
    <button id="new-game">Nuevo Juego</button>
    <button id="scoreboard-button">Puntuación</button>
    <div id="round-info"></div>
    <div id="message"></div>
    <div id="trick-area"></div>
    
    <div id="north" class="player-area">
      <div id="player-0-name"></div>
      <div id="player-0-status" class="status-box"></div>
      <div id="player-0-hand"></div>
    </div>
    <div id="east" class="player-area">
      <div id="player-1-name"></div>
      <div id="player-1-status" class="status-box"></div>
      <div id="player-1-hand"></div>
    </div>
    <div id="south" class="player-area">
      <div id="bid-area"></div>
      <div id="player-2-name"></div>
      <div id="player-2-status" class="status-box"></div>
      <div id="player-2-hand"></div>
    </div>
    <div id="west" class="player-area">
      <div id="player-3-name"></div>
      <div id="player-3-status" class="status-box"></div>
      <div id="player-3-hand"></div>
    </div>
    <button id="restart">Siguiente Ronda</button>
  </div>

  <!-- Scoreboard Overlay -->
  <div id="scoreboard-overlay" style="display: none;">
    <div id="scoreboard-close">X</div>
    <div id="scoreboard-content"></div>
  </div>

  <script>
    /***********************
     * VARIABLES Y ESTADO DEL JUEGO
     ***********************/
    const suitOrder = { "oros": 0, "bastos": 1, "copas": 2, "espadas": 3 };
    let players = [
      { id: 0, name: "AI North", type: "ai", hand: [], bid: null, tricks: 0, score: 0, position: "north" },
      { id: 1, name: "AI East", type: "ai", hand: [], bid: null, tricks: 0, score: 0, position: "east" },
      { id: 2, name: "Tú", type: "human", hand: [], bid: null, tricks: 0, score: 0, position: "south" },
      { id: 3, name: "AI West", type: "ai", hand: [], bid: null, tricks: 0, score: 0, position: "west" }
    ];
    let deck = [];
    let trump = null;
    let trumpSuit = null;
    let dealer = null;
    let biddingOrder = [];
    let biddingIndex = 0;
    let currentPhase = "bidding"; // "bidding", "playing" o "roundOver"
    let currentTrick = [];
    let trickLeader = null;
    let currentPlayer = null;
    const rounds = [1,2,3,4,5,5,5,5,5,5,5,5,4,3,2,1];
    let currentRoundIndex = 0;
    let handSize = rounds[currentRoundIndex];
    // Array global para almacenar la info de cada ronda (16 rondas)
    let scoreData = [];

    /***********************
     * ASIGNAR NOMBRES ALEATORIOS A LAS IA
     * (Nombres famosos con máximo 7 letras)
     ***********************/
    function assignAINames() {
      const aiNames = ["Newton", "Curie", "Tesla", "Hawkin", "Galilei", "Fermi", "Bohr", "Dirac", "Planck"];
      // Mezcla el array
      for (let i = aiNames.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [aiNames[i], aiNames[j]] = [aiNames[j], aiNames[i]];
      }
      let count = 0;
      players.forEach(p => {
        if (p.type === "ai") {
          p.name = aiNames[count];
          count++;
        }
      });
    }

    /***********************
     * FUNCIONES AUXILIARES DEL JUEGO
     ***********************/
    function createDeck() {
      const suits = ["espadas", "oros", "copas", "bastos"];
      const ranks = ["1","2","3","4","5","6","7","8","9","S","C","R"];
      let deck = [];
      for (let suit of suits) {
        for (let rank of ranks) {
          deck.push({ suit, rank });
        }
      }
      return deck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getRankValue(rank) {
      const rankOrder = {
        "1": 12,
        "3": 11,
        "R": 10,
        "C": 9,
        "S": 8,
        "9": 7,
        "8": 6,
        "7": 5,
        "6": 4,
        "5": 3,
        "4": 2,
        "2": 1
      };
      return rankOrder[rank] || 0;
    }

    function getSuitSymbol(suit) {
      switch (suit) {
        case "espadas": return "E";
        case "oros":    return "O";
        case "copas":   return "C";
        case "bastos":  return "B";
        default: return "";
      }
    }

    // Crea un elemento <img> para la carta.
    function createCardElement(card, faceUp = true) {
      let img = document.createElement("img");
      img.classList.add("card");
      img.width = 94;
      img.height = 140;
      if (!faceUp) {
        img.src = "img/reverso-hd.png";
      } else {
        let num;
        if (card.rank === "S") num = "10";
        else if (card.rank === "C") num = "11";
        else if (card.rank === "R") num = "12";
        else num = card.rank;
        let suitInitial = "";
        if (card.suit === "oros") suitInitial = "o";
        else if (card.suit === "bastos") suitInitial = "b";
        else if (card.suit === "copas") suitInitial = "c";
        else if (card.suit === "espadas") suitInitial = "e";
        img.src = "img/" + num + suitInitial + "-hd.png";
      }
      return img;
    }

    function updateHandsDisplay() {
      for (let p of players) {
        let handDiv = document.getElementById(`player-${p.id}-hand`);
        handDiv.innerHTML = "";
        if (p.type === "human") {
          p.hand.sort((a, b) => {
            if (suitOrder[a.suit] !== suitOrder[b.suit]) {
              return suitOrder[a.suit] - suitOrder[b.suit];
            } else {
              return getRankValue(b.rank) - getRankValue(a.rank);
            }
          });
        }
        for (let i = 0; i < p.hand.length; i++) {
          let card = p.hand[i];
          let cardEl;
          if (p.type === "human") {
            cardEl = createCardElement(card, true);
            cardEl.dataset.index = i;
            if (currentPhase === "playing" && p.id === currentPlayer && isLegalPlay(p, card)) {
              cardEl.classList.add("valid");
            }
            if (p.id === currentPlayer && currentPhase === "playing") {
              cardEl.addEventListener("click", onHumanCardClick);
            }
          } else {
            cardEl = createCardElement(card, false);
          }
          handDiv.appendChild(cardEl);
        }
      }
    }

    function updatePlayerInfo() {
      players.forEach(p => {
        let nameDiv = document.getElementById(`player-${p.id}-name`);
        nameDiv.textContent = p.name + (p.id === dealer ? " (Dealer)" : "");
        let statusDiv = document.getElementById(`player-${p.id}-status`);
        statusDiv.textContent = "Apuesta: " + (p.bid !== null ? p.bid : "-") +
                                " | Bazas: " + p.tricks +
                                " | Puntuación: " + p.score;
      });
    }

    function updateRoundInfo() {
      let roundInfoDiv = document.getElementById("round-info");
      roundInfoDiv.innerHTML = "";
      let roundText = document.createElement("div");
      roundText.textContent = "Ronda: " + (currentRoundIndex + 1) + " de " + rounds.length;
      roundInfoDiv.appendChild(roundText);
      let trumpText = document.createElement("div");
      trumpText.textContent = "Triunfo";
      roundInfoDiv.appendChild(trumpText);
      let trumpCardEl = createCardElement(trump, true);
      trumpCardEl.style.width = "40px";
      trumpCardEl.style.height = "60px";
      trumpCardEl.style.lineHeight = "60px";
      trumpCardEl.style.fontSize = "16px";
      roundInfoDiv.appendChild(trumpCardEl);
    }

    function showMessage(text) {
      document.getElementById("message").textContent = text;
    }

    function clearBidArea() {
      document.getElementById("bid-area").innerHTML = "";
    }

    function clearTrickArea() {
      document.getElementById("trick-area").innerHTML = "";
    }

    /***********************
     * FUNCIONES AUXILIARES PARA LA MEJORA DE LA IA
     ***********************/
    // Determina si cardA vence a cardB en la baza actual
    function cardBeats(cardA, cardB, ledSuit, trumpSuit) {
      if (cardA.suit === cardB.suit) {
        return getRankValue(cardA.rank) > getRankValue(cardB.rank);
      }
      if (cardA.suit === trumpSuit && cardB.suit !== trumpSuit) {
        return true;
      }
      return false;
    }

    // La IA selecciona la carta a jugar de forma inteligente
    function aiSelectCard(player) {
      let legalIndices = [];
      for (let i = 0; i < player.hand.length; i++) {
        if (isLegalPlay(player, player.hand[i])) {
          legalIndices.push(i);
        }
      }
      if (legalIndices.length === 0) legalIndices = player.hand.map((c, i) => i);
      if (currentTrick.length === 0) {
        let nonTrumpIndices = legalIndices.filter(i => player.hand[i].suit !== trumpSuit);
        if (nonTrumpIndices.length > 0) {
          let bestIndex = nonTrumpIndices[0];
          for (let idx of nonTrumpIndices) {
            if (getRankValue(player.hand[idx].rank) < getRankValue(player.hand[bestIndex].rank)) {
              bestIndex = idx;
            }
          }
          return bestIndex;
        } else {
          let bestIndex = legalIndices[0];
          for (let idx of legalIndices) {
            if (getRankValue(player.hand[idx].rank) < getRankValue(player.hand[bestIndex].rank)) {
              bestIndex = idx;
            }
          }
          return bestIndex;
        }
      } else {
        let ledSuit = currentTrick[0].card.suit;
        let currentWinning = currentTrick[0].card;
        for (let i = 1; i < currentTrick.length; i++) {
          let candidate = currentTrick[i].card;
          if (cardBeats(candidate, currentWinning, ledSuit, trumpSuit)) {
            currentWinning = candidate;
          }
        }
        let winningCandidates = legalIndices.filter(i =>
          cardBeats(player.hand[i], currentWinning, ledSuit, trumpSuit)
        );
        if (winningCandidates.length > 0) {
          let bestIndex = winningCandidates[0];
          for (let idx of winningCandidates) {
            let candidate = player.hand[idx];
            let bestCandidate = player.hand[bestIndex];
            if (candidate.suit === bestCandidate.suit) {
              if (getRankValue(candidate.rank) < getRankValue(bestCandidate.rank)) {
                bestIndex = idx;
              }
            } else {
              if (candidate.suit !== trumpSuit && bestCandidate.suit === trumpSuit) {
                bestIndex = idx;
              }
            }
          }
          return bestIndex;
        } else {
          let bestIndex = legalIndices[0];
          for (let idx of legalIndices) {
            let candidate = player.hand[idx];
            let bestCandidate = player.hand[bestIndex];
            if (candidate.suit !== trumpSuit && bestCandidate.suit === trumpSuit) {
              bestIndex = idx;
            } else if (getRankValue(candidate.rank) < getRankValue(bestCandidate.rank)) {
              bestIndex = idx;
            }
          }
          return bestIndex;
        }
      }
    }

    /***********************
     * LÓGICA DEL JUEGO
     ***********************/
    function startRound() {
      // Si es la primera ronda de la partida, asignamos nombres aleatorios a las IA
      if (currentRoundIndex === 0) {
        assignAINames();
      }
      currentPhase = "bidding";
      currentTrick = [];
      biddingIndex = 0;
      handSize = rounds[currentRoundIndex];
      players.forEach(p => {
        p.hand = [];
        p.bid = null;
        p.tricks = 0;
      });
      clearTrickArea();
      clearBidArea();
      document.getElementById("restart").style.display = "none";
      deck = createDeck();
      shuffle(deck);
      for (let i = 0; i < handSize; i++) {
        for (let p of players) {
          p.hand.push(deck.pop());
        }
      }
      trump = deck.pop();
      trumpSuit = trump.suit;
      dealer = Math.floor(Math.random() * players.length);
      biddingOrder = [];
      for (let i = 1; i <= players.length; i++) {
        biddingOrder.push((dealer + i) % players.length);
      }
      updatePlayerInfo();
      updateHandsDisplay();
      updateRoundInfo();
      showMessage("Trump: " + getSuitSymbol(trumpSuit) + " (" + trumpSuit + ")");
      setTimeout(processNextBid, 1000);
    }

    function processNextBid() {
      if (biddingIndex >= biddingOrder.length) {
        currentPhase = "playing";
        trickLeader = biddingOrder[0];
        currentPlayer = trickLeader;
        showMessage("Apuestas completas. " + players[currentPlayer].name + " lidera.");
        updatePlayerInfo();
        setTimeout(playTurn, 1000);
        return;
      }
      let pid = biddingOrder[biddingIndex];
      let p = players[pid];
      if (p.type === "ai") {
        let bid = aiComputeBid(pid);
        p.bid = bid;
        showMessage(p.name + " apuesta " + bid);
        updatePlayerInfo();
        biddingIndex++;
        setTimeout(processNextBid, 1000);
      } else {
        showMessage("Tu turno para apostar. Elige un número entre 0 y " + handSize + ".");
        displayBidOptions();
      }
    }

    function displayBidOptions() {
      clearBidArea();
      let bidArea = document.getElementById("bid-area");
      for (let i = 0; i <= handSize; i++) {
        let btn = document.createElement("button");
        btn.textContent = i;
        btn.classList.add("bid-button");
        btn.addEventListener("click", function() {
          players[2].bid = i;
          showMessage("Apuestas: " + i);
          updatePlayerInfo();
          clearBidArea();
          biddingIndex++;
          setTimeout(processNextBid, 500);
        });
        bidArea.appendChild(btn);
      }
    }

    // Nueva versión de aiComputeBid: evalúa cada carta, dando mayor peso a las cartas de triunfo
    function aiComputeBid(pid) {
      let p = players[pid];
      let expectedTricks = 0;
      for (let card of p.hand) {
        if (card.suit === trumpSuit) {
          expectedTricks += getRankValue(card.rank) / 12;
        } else {
          if (card.rank === "1" || card.rank === "3") {
            expectedTricks += 0.5;
          }
        }
      }
      let bid = Math.round(expectedTricks + (Math.random() * 0.5 - 0.25));
      if (bid < 0) bid = 0;
      if (bid > handSize) bid = handSize;
      return bid;
    }

    // Regla para jugar: si el jugador tiene cartas del mismo palo que abrió la baza, debe jugarlas;
    // si no, si tiene cartas de triunfo, debe jugarlas; de lo contrario, puede jugar cualquier carta.
    function isLegalPlay(player, card) {
      if (currentTrick.length === 0) return true;
      let ledSuit = currentTrick[0].card.suit;
      let hasLedSuit = player.hand.some(c => c.suit === ledSuit);
      if (hasLedSuit) {
        return card.suit === ledSuit;
      } else {
        let hasTrump = player.hand.some(c => c.suit === trumpSuit);
        if (hasTrump) {
          return card.suit === trumpSuit;
        } else {
          return true;
        }
      }
    }

    function onHumanCardClick(event) {
      let index = parseInt(event.currentTarget.dataset.index);
      let card = players[2].hand[index];
      if (!isLegalPlay(players[2], card)) {
        showMessage("¡Debes seguir el palo o, si no lo tienes, tirar triunfo!");
        return;
      }
      playCard(2, index);
    }

    // Posiciones de las cartas jugadas en el tapete (para un contenedor de 350×350px)
    function playCard(playerId, cardIndex) {
      let player = players[playerId];
      let card = player.hand.splice(cardIndex, 1)[0];
      let cardEl = createCardElement(card, true);
      cardEl.classList.add("played-card");
      let pos = "";
      switch (player.position) {
        case "north": pos = "top: 10px; left: 128px;"; break;
        case "south": pos = "bottom: 10px; left: 128px;"; break;
        case "east":  pos = "right: 10px; top: 105px;"; break;
        case "west":  pos = "left: 10px; top: 105px;"; break;
      }
      cardEl.style.cssText += pos;
      document.getElementById("trick-area").appendChild(cardEl);
      currentTrick.push({ playerId, card, element: cardEl });
      updateHandsDisplay();
      updateWinningCardHighlight();
      if (currentTrick.length === players.length) {
        setTimeout(determineTrickWinner, 1000);
      } else {
        currentPlayer = (playerId + 1) % players.length;
        while (players[currentPlayer].hand.length === 0) {
          currentPlayer = (currentPlayer + 1) % players.length;
        }
        setTimeout(playTurn, 500);
      }
    }

    // Función playTurn que utiliza la IA inteligente
    function playTurn() {
      updateHandsDisplay();
      let p = players[currentPlayer];
      if (p.type === "ai") {
        showMessage(p.name + " está jugando...");
        setTimeout(function() {
          let choice = aiSelectCard(p);
          playCard(currentPlayer, choice);
        }, 1000);
      } else {
        showMessage("Tu turno. Haz clic en una carta resaltada.");
        updateHandsDisplay();
      }
    }

    function determineTrickWinner() {
      let ledSuit = currentTrick[0].card.suit;
      let winningCard = null;
      let winner = null;
      let trumps = currentTrick.filter(t => t.card.suit === trumpSuit);
      if (trumps.length > 0) {
        winningCard = trumps.reduce((prev, cur) =>
          getRankValue(cur.card.rank) > getRankValue(prev.card.rank) ? cur : prev
        );
      } else {
        let ledCards = currentTrick.filter(t => t.card.suit === ledSuit);
        winningCard = ledCards.reduce((prev, cur) =>
          getRankValue(cur.card.rank) > getRankValue(prev.card.rank) ? cur : prev
        );
      }
      winner = winningCard.playerId;
      players[winner].tricks++;
      updatePlayerInfo();
      showMessage(players[winner].name + " gana la baza.");
      animateTrickCards(winner);
    }

    function updateWinningCardHighlight() {
      if (currentTrick.length === 0) return;
      let ledSuit = currentTrick[0].card.suit;
      let winningItem = null;
      let trumpItems = currentTrick.filter(item => item.card.suit === trumpSuit);
      if (trumpItems.length > 0) {
        winningItem = trumpItems.reduce((prev, cur) =>
          getRankValue(cur.card.rank) > getRankValue(prev.card.rank) ? cur : prev
        );
      } else {
        let ledItems = currentTrick.filter(item => item.card.suit === ledSuit);
        if (ledItems.length > 0) {
          winningItem = ledItems.reduce((prev, cur) =>
            getRankValue(cur.card.rank) > getRankValue(prev.card.rank) ? cur : prev
          );
        }
      }
      currentTrick.forEach(item => item.element.classList.remove("winning-card"));
      if (winningItem) {
        winningItem.element.classList.add("winning-card");
      }
    }

    function animateTrickCards(winner) {
      let direction = "";
      if (players[winner].position === "north") {
        direction = "translateY(-100%)";
      } else if (players[winner].position === "south") {
        direction = "translateY(100%)";
      } else if (players[winner].position === "east") {
        direction = "translateX(100%)";
      } else if (players[winner].position === "west") {
        direction = "translateX(-100%)";
      }
      currentTrick.forEach(item => {
        let el = item.element;
        el.style.transition = "all 0.5s ease-out";
        el.style.transform = direction;
        el.style.opacity = "0";
      });
      setTimeout(() => {
        clearTrickArea();
        currentTrick = [];
        currentPlayer = winner;
        if (players[0].hand.length > 0) {
          setTimeout(playTurn, 500);
        } else {
          endRound();
        }
      }, 600);
    }

    function endRound() {
      currentPhase = "roundOver";
      players.forEach(p => {
        if (p.bid === p.tricks) {
          p.score += (10 + 3 * p.tricks);
        } else {
          p.score -= 3 * Math.abs(p.tricks - p.bid);
        }
      });
      let roundResult = { round: currentRoundIndex + 1, handSize: handSize, results: [] };
      players.forEach(p => {
        let roundPoints = (p.bid === p.tricks) ? (10 + 3 * p.tricks) : (-3 * Math.abs(p.tricks - p.bid));
        roundResult.results.push({ roundPoints: roundPoints, total: p.score });
      });
      scoreData.push(roundResult);
      updatePlayerInfo();
      let summary = "Ronda finalizada. ";
      players.forEach(p => {
        summary += p.name + " apostó " + p.bid + " y consiguió " + p.tricks + " baza" + (p.tricks !== 1 ? "s" : "") + ". ";
      });
      showMessage(summary);
      let restartBtn = document.getElementById("restart");
      restartBtn.textContent = (currentRoundIndex < rounds.length - 1) ? "Siguiente Ronda" : "Reiniciar Juego";
      restartBtn.style.display = "block";
    }

    /***********************
     * TABLA DE PUNTUACIÓN
     ***********************/
    function showScoreboard() {
      let contentDiv = document.getElementById("scoreboard-content");
      contentDiv.innerHTML = "";
      let table = document.createElement("table");
      table.id = "scoreboard-table";
      table.style.borderCollapse = "collapse";
      // Cabecera: el orden deseado es: Ronda, AI West, AI North, AI East, Tú
      let scoreboardOrder = [];
      // Se buscan las IA por posición y luego se añade el humano
      scoreboardOrder.push(players.find(p => p.position === "west"));
      scoreboardOrder.push(players.find(p => p.position === "north"));
      scoreboardOrder.push(players.find(p => p.position === "east"));
      scoreboardOrder.push(players.find(p => p.type === "human"));
      
      let thead = document.createElement("thead");
      let headerRow1 = document.createElement("tr");
      let thRonda = document.createElement("th");
      thRonda.colSpan = 2;
      thRonda.textContent = "Ronda";
      thRonda.classList.add("main-column");
      headerRow1.appendChild(thRonda);
      scoreboardOrder.forEach((p, index) => {
        let thPlayer = document.createElement("th");
        thPlayer.colSpan = 2;
        thPlayer.textContent = p.name;
        if (index < scoreboardOrder.length - 1) {
          thPlayer.classList.add("main-column");
        }
        headerRow1.appendChild(thPlayer);
      });
      thead.appendChild(headerRow1);
      let headerRow2 = document.createElement("tr");
      let thRoundNum = document.createElement("th");
      thRoundNum.textContent = "Número";
      headerRow2.appendChild(thRoundNum);
      let thHand = document.createElement("th");
      thHand.textContent = "Cartas";
      headerRow2.appendChild(thHand);
      scoreboardOrder.forEach(() => {
        let thPoints = document.createElement("th");
        thPoints.textContent = "Puntos";
        headerRow2.appendChild(thPoints);
        let thTotal = document.createElement("th");
        thTotal.textContent = "Total";
        headerRow2.appendChild(thTotal);
      });
      thead.appendChild(headerRow2);
      table.appendChild(thead);
      // Cuerpo de la tabla: 16 filas (una por ronda)
      let tbody = document.createElement("tbody");
      for (let i = 1; i <= 16; i++) {
        let tr = document.createElement("tr");
        if (i === 4 || i === 12) {
          tr.classList.add("separator");
        }
        let tdRound = document.createElement("td");
        tdRound.textContent = i;
        tr.appendChild(tdRound);
        let tdHand = document.createElement("td");
        if (scoreData[i - 1]) {
          tdHand.textContent = scoreData[i - 1].handSize;
        } else {
          tdHand.textContent = "";
        }
        tr.appendChild(tdHand);
        scoreboardOrder.forEach((p, index) => {
          let tdPoints = document.createElement("td");
          let tdTotal = document.createElement("td");
          if (scoreData[i - 1]) {
            // Buscamos el resultado correspondiente al jugador de scoreboardOrder
            let playerIndex = players.indexOf(p);
            let res = scoreData[i - 1].results[playerIndex];
            tdPoints.textContent = res.roundPoints;
            tdTotal.textContent = res.total;
            if (res.roundPoints < 0) {
              tdPoints.style.color = "red";
            }
            if (res.total < 0) {
              tdTotal.style.color = "red";
            }
          } else {
            tdPoints.textContent = "";
            tdTotal.textContent = "";
          }
          tr.appendChild(tdPoints);
          tr.appendChild(tdTotal);
        });
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      contentDiv.appendChild(table);
      document.getElementById("scoreboard-overlay").style.display = "block";
    }

    function hideScoreboard() {
      document.getElementById("scoreboard-overlay").style.display = "none";
    }

    /***********************
     * EVENTOS DEL SCOREBOARD
     ***********************/
    document.getElementById("scoreboard-button").addEventListener("click", showScoreboard);
    document.getElementById("scoreboard-close").addEventListener("click", hideScoreboard);

    /***********************
     * EVENTOS DEL JUEGO
     ***********************/
    document.getElementById("restart").addEventListener("click", function() {
      document.getElementById("restart").style.display = "none";
      if (currentRoundIndex < rounds.length - 1) {
        currentRoundIndex++;
        startRound();
      } else {
        alert("Juego terminado. Se reiniciará el juego.");
        currentRoundIndex = 0;
        players.forEach(p => p.score = 0);
        scoreData = [];
        startRound();
      }
    });

    document.getElementById("new-game").addEventListener("click", function() {
      currentRoundIndex = 0;
      players.forEach(p => p.score = 0);
      scoreData = [];
      assignAINames();
      startRound();
    });

    /***********************
     * INICIO DEL JUEGO
     ***********************/
    startRound();
  </script>
</body>
</html>
